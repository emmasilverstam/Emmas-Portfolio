<!DOCTYPE html>
<html lang="en" class="surf">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <link href="css/normalize.css" rel="stylesheet" />
    <link rel="stylesheet" href="../css/Endobreath.css" />
    <link rel="stylesheet" href="https://unicons.iconscout.com/release/v4.0.8/css/line.css">
    <title>EndoBreathe</title>
</head>

<body>
    <div id="container">
        <header>
            <nav>
                <div class="hamburger-menu">
                    <div class="bar"></div>
                    <div class="bar"></div>
                    <div class="bar"></div>
                </div>
                <ul>
                    <li><a href="../index.html#header">Home</a></li>
                    <li><a href="../index.html#project">Projects</a></li>
                    <li><a href="../index.html#about">About me</a></li>
                    <li><a href="../index.html#contact">Contacts</a></li>
                </ul>
            </nav>
        </header>
    </div>

    <section>
        <div class="info">
            <div>
                <h1>A pillow for endometriosis</h1>
                <p><span>Type:</span> Individual work</p>
                <p><span>When:</span> 2023</p>
                <p><span>Duration:</span> Four weeks, half time</p>
                <p><span>Project scope:</span> School project in Concept-Driven Interaction Design</p>
                <p>This project used a soma design process to explore how design can foster body awareness and self-compassion during endometriosis-related pain. Through first-person exploration and somatic prototyping, it examined how warmth, weight, and breathing rhythms could help reconnect with the body. The resulting design, EndoBreathe, is a soft heating pillow that synchronises light and warmth with the user’s breath, creating moments of calm and embodied presence. </p>
            </div>
            <div class="pendel"><img src="../EndoBreathe/icon-09.png"></div>
        </div>
        <div class="sketch"><h2>The process</h2></div>
        <div class="step_2">
            <div class="sketches"><img src="../EndoBreathe/process.png" class="helmet1"></div>
        </div>
        <div class="step_1" id="moodboard-section">
        <div class="mood">
            <img src="../EndoBreathe/conceptportrait.png" alt="Moodboard">
        </div>
        <div>
            <h2>Concept portrait</h2>
            <p>A mood board was created to establish a shared understanding of the emotions the product should evoke.</p>
        </div>
        </div>
        <!-- Mirrored section: text left, image right -->
        <div class="step_1" id="moodboard-right-section">
          <div>
            <h2>First-person perspective</h2>
            <p>A body map captured the location and qualities of pain to guide placement and interaction.</p>
          </div>
          <div class="mood">
            <img src="../EndoBreathe/first-person.png" alt="Body map">
          </div>
        </div>
        <!-- Pink gallery block -->
        <section class="pink-section" id="bodymap-gallery">
          <div class="pink-wrap">
            <h2>Body mapping</h2>
            <p class="pink-intro">
              Visualising how pain and emotions move through the body helped guide the design process.
            </p>
            <div class="pink-grid">
              <figure><img src="../EndoBreathe/soma1.png" alt="Body map 1"></figure>
              <figure><img src="../EndoBreathe/soma2.png" alt="Body map 2"></figure>
              <figure><img src="../EndoBreathe/soma3.png" alt="Body map 3"></figure>
            </div>
          </div>
        </section>
        <!-- 1️⃣ Concept portrait -->
        <div class="step_1" id="moodboard-section-1">
          <div class="mood">
            <img src="../EndoBreathe/prototyping.png" alt="Concept portrait">
          </div>
          <div>
            <h2>Sensory Prototyping</h2>
            <p>A mood board was created to establish a shared understanding of the emotions the product should evoke.</p>
          </div>
        </div>

        <!-- 2️⃣ First-person perspective (bild höger) -->
        <div class="step_1" id="moodboard-section-2">
          <div>
            <h2>Love Letter</h2>
            <p>Notes from pain diaries and reflections were used to capture embodied experiences of endometriosis.</p>
          </div>
          <div class="mood">
            <img src="../EndoBreathe/loveletter.png" alt="First-person perspective">
          </div>
        </div>

        <!-- 3️⃣ Body mapping (bild vänster) -->
        <div class="step_1" id="moodboard-section-3">
          <div class="mood">
            <img src="../EndoBreathe/moodboard.png" alt="Body mapping">
          </div>
          <div>
            <h2>Moodboard</h2>
            <p>Body mapping visualised where and how pain was felt, helping identify areas for design interaction.</p>
          </div>
        </div>

        <!-- 4️⃣ Trajectory (bild höger) -->
        <div class="step_1" id="moodboard-section-4">
          <div>
            <h2>Digital Sketching</h2>
            <p>The trajectory method mapped variations in pain, breath, and presence over time to reveal design opportunities.</p>
          </div>
          <div class="mood">
            <img src="../EndoBreathe/sketching-01.png" alt="Trajectory">
          </div>
        </div>
        <!-- 5️⃣ Sensory prototyping (bild vänster) -->
        <div class="step_1" id="moodboard-section-5">
          <div class="mood">
            <img src="../EndoBreathe/prototype2.png" alt="Sensory prototyping">
          </div>
          <div>
            <h2>Test and Mid-fidelity prototyping</h2>
            <p>Different materials, warmth, and pressure were explored to understand how tactile sensations can evoke presence and comfort.</p>
          </div>
        </div>
<section class="pink-video-split" id="video-block">
  <div class="text-side">
    <h2>The Result</h2>
    <p>
      The video illustrates how EndoBreathe supports the body through synchronized warmth and breathing rhythms. 
      The heating element follows each inhale and exhale, helping the user reconnect with the body during pain.
    </p>
  </div>

  <div class="video-side">
    <video
      src="../EndoBreathe/Video_slide30 - kopia.mp4"
      controls
      playsinline
      preload="metadata"
      poster="../EndoBreathe/pillow-01 - kopia.png"
    ></video>
  </div>
</section>
<section id="result-gallery" aria-label="The result — image gallery">
  <div class="rg-wrap">
    <h2 class="rg-title">Design Details</h2>
    <p class="rg-intro" id="rg-caption">
      Final appearance and feel of the prototype in use.
    </p>
  </div>

  <!-- Pink box -->
  <div class="rg-viewport" role="region" aria-roledescription="carousel" aria-labelledby="rg-caption">
    <!-- Slides (positioned in the same center spot; JS toggles visibility) -->
    <figure class="rg-slide" data-index="0" aria-hidden="false">
      <img src="../EndoBreathe/pic1-01-01.png" alt="Heating element test">
    </figure>

    <figure class="rg-slide" data-index="1" aria-hidden="true">
      <img src="../EndoBreathe/pic2-02-02.png" alt="Breathing-synchronised light prototype">
    </figure>

    <figure class="rg-slide" data-index="2" aria-hidden="true">
      <img src="../EndoBreathe/pic3-03.png" alt="Fabric and weight exploration">
    </figure>

    <figure class="rg-slide" data-index="3" aria-hidden="true">
      <img src="../EndoBreathe/pic4-04.png" alt="Embedded LED integration">
    </figure>

    <figure class="rg-slide" data-index="4" aria-hidden="true">
      <img src="../EndoBreathe/pic5-05.png" alt="Form and placement test">
    </figure>

    <figure class="rg-slide" data-index="5" aria-hidden="true">
      <img src="../EndoBreathe/pic6-06.png" alt="Final appearance">
    </figure>

    <!-- Controls -->
    <button type="button" class="rg-btn rg-prev" aria-label="Previous image" data-dir="-1">‹</button>
    <button type="button" class="rg-btn rg-next" aria-label="Next image" data-dir="1">›</button>
  </div>
</section>




        </section>
   <div class="result">
      <h2>The Prototype</h2>
      <p>As the project progressed, our prototypes became increasingly detailed. We began with low-fidelity mockups to explore ideas and gather early reactions, and later moved toward higher-fidelity versions that were closer to the final product.

One of the key methods we used was a Wizard of Oz prototype to simulate light and sound interactions and observe how users responded. This approach allowed us to test the experience without developing a fully functional version, making it both time-efficient and flexible for iteration.

User feedback from these tests helped us refine several aspects of the design, such as the placement and type of light to improve comfort and usability. The prototype provided a solid foundation for iteration, as it enabled quick adjustments and new rounds of testing.</p>
    </div>
    <div class="step_3">
      <div class="pic1 pop-in"><img src="../EndoBreathe/bilden1-01.png" alt=""></div>
      <div class="pic2 pop-in"><img src="../EndoBreathe/bilden2-02.png" alt=""></div>
      <div class="pic3 pop-in">
        <video src="../EndoBreathe/Video_slide31 - kopia.mp4" autoplay muted loop playsinline></video>
      </div>
    </div>





  
    <footer>

    </footer>
</body>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        // Select the pendulum images
        var pendel2 = document.querySelector('.pendel2 img');
        var pendel3 = document.querySelector('.pendel3 img');

        // Select the arrows
        var arrow2 = document.querySelector('.arrow.arrow2');
        var arrow3 = document.querySelector('.arrow.arrow3');

        // Add a class to the arrows just before the corresponding pendulum images are displayed
        pendel2.addEventListener('animationstart', function () {
            arrow2.style.display = 'block';
        });

        pendel3.addEventListener('animationstart', function () {
            arrow3.style.display = 'block';
        });
    });
</script>

<script>
    document.addEventListener('DOMContentLoaded', function () {
      const hamburgerMenu = document.querySelector('.hamburger-menu');
      const navLinks = document.querySelector('nav ul');
      const galleryItems = document.querySelectorAll('.gallery__item');
  
      // Add click event for hamburger menu
      hamburgerMenu.addEventListener('click', function () {
        hamburgerMenu.classList.toggle('active');
        navLinks.classList.toggle('active');
      });
  
      // Add click event for gallery items
      galleryItems.forEach(function (item) {
        item.addEventListener('click', function () {
          // Toggle a class to change the background color on tap/click
          this.classList.toggle('active');
        });
      });
    });
  </script>
  <script>
  const wrapper = document.querySelector('.video-wrapper');
  const video   = document.getElementById('melofloraVideo');
  const overlay = document.querySelector('.video-overlay');
  const playBtn = document.querySelector('.play-btn');

  // Visa första bildrutan (slipper grå/vit skärm)
  video.addEventListener('loadeddata', () => {
    video.pause();
    video.currentTime = 0;
  });

  // Starta uppspelning
  playBtn.addEventListener('click', () => {
    wrapper.classList.add('playing');
    // börja från start om vi var i slutet
    if (video.currentTime >= video.duration - 0.05) video.currentTime = 0;
    video.play();
  });

  // När videon slutar: visa overlay igen för replay
  video.addEventListener('ended', () => {
    wrapper.classList.remove('playing');
    video.currentTime = 0;
    // overlay syns igen -> användaren kan klicka play
  });

  // Om användaren pausar: visa overlay igen
  video.addEventListener('pause', () => {
    if (video.currentTime < video.duration) {
      wrapper.classList.remove('playing');
    }
  });
</script>
<script>
  (function () {
    const gallery = document.getElementById('prototyping-gallery');
    if (!gallery) return;

    // Fallback: visa utan animation om IO saknas
    if (!('IntersectionObserver' in window)) {
      gallery.classList.add('in-view');
      return;
    }

    const io = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && entry.intersectionRatio > 0.25) {
          // Lägg på klass → starta stagger-animation
          gallery.classList.add('in-view');
        } else {
          // Ta bort klass → nollställ, så den kan spelas igen
          gallery.classList.remove('in-view');
        }
      });
    }, {
      root: null,
      threshold: [0, 0.25, 0.5],   // stabilare toggling
      rootMargin: '0px 0px -10% 0px'
    });

    io.observe(gallery);
  })();
</script>
<script>
  (function () {
    const section = document.getElementById('result-section');
    if (!section) return;

    if (!('IntersectionObserver' in window)) {
      section.classList.add('visible');
      return;
    }

    const io = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        // fade in
        if (entry.isIntersecting && entry.intersectionRatio > 0.25) {
          section.classList.add('visible');
        }
        // fade ut
        else if (!entry.isIntersecting) {
          section.classList.remove('visible');
        }
      });
    }, {
      root: null,
      threshold: [0, 0.25, 0.5],
      rootMargin: '0px 0px -10% 0px'
    });

    io.observe(section);
  })();
</script>
<script>
(function () {
  const img = document.querySelector('#moodboard-section .mood img');
  if (!img) return;

  // Mjuk easing så det känns snällt
  const easeOutCubic = t => 1 - Math.pow(1 - t, 3);

  let ticking = false;

  function update() {
    ticking = false;

    const rect = img.getBoundingClientRect();
    const vh   = window.innerHeight;

    // När ska vi börja/sluta animera?
    // startY: när bildens top når 85% av viewportens höjd (ganska långt ner)
    // endY:   när bildens top når 35% av viewportens höjd (ungefär mitt)
    const startY = vh * 0.85;
    const endY   = vh * 0.35;

    // Progress 0..1 mellan start→slut (klämd)
    let p = (startY - rect.top) / (startY - endY);
    p = Math.min(Math.max(p, 0), 1);

    // Easing
    const e = easeOutCubic(p);

    // Från -160px → 0px och 0 → 1 i opacity
    const tx = -160 * (1 - e);
    img.style.transform = `translateX(${tx}px)`;
    img.style.opacity = String(e);
  }

  function onScroll() {
    if (!ticking) {
      ticking = true;
      requestAnimationFrame(update);
    }
  }

  // Kör vid start + på scroll/resize
  window.addEventListener('scroll', onScroll, { passive: true });
  window.addEventListener('resize', onScroll, { passive: true });
  update();
})();
</script>
<script>
(function () {
  const img = document.querySelector('#pattern-section img');
  if (!img) return;

  const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
  let ticking = false;

  function update() {
    ticking = false;

    const rect = img.getBoundingClientRect();
    const vh = window.innerHeight;

    // Startar när bilden börjar synas långt nere, avslutar runt mitten
    const startY = vh * 0.9;
    const endY = vh * 0.3;

    // Beräkna progress mellan 0–1
    let p = (startY - rect.top) / (startY - endY);
    p = Math.min(Math.max(p, 0), 1);

    const e = easeOutCubic(p);

    // Från 100vw (helt utanför till höger) → 0px (på plats)
    const tx = 100 * (1 - e);
    img.style.transform = `translateX(${tx}vw)`;
    img.style.opacity = e;
  }

  function onScroll() {
    if (!ticking) {
      ticking = true;
      requestAnimationFrame(update);
    }
  }

  window.addEventListener('scroll', onScroll, { passive: true });
  window.addEventListener('resize', onScroll, { passive: true });
  update();
})();
</script>
<script>
(function () {
  const img = document.querySelector('#moodboard-right-section .mood img');
  if (!img) return;

  const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
  let ticking = false;

  function update() {
    ticking = false;

    const rect = img.getBoundingClientRect();
    const vh   = window.innerHeight;

    const startY = vh * 0.85;  // börja animera sent
    const endY   = vh * 0.35;  // klart runt mitten

    let p = (startY - rect.top) / (startY - endY);
    p = Math.min(Math.max(p, 0), 1);

    const e = easeOutCubic(p);

    // Höger-in: +160px -> 0
    const tx = 160 * (1 - e);
    img.style.transform = `translateX(${tx}px)`;
    img.style.opacity = String(e);
  }

  function onScroll() {
    if (!ticking) {
      ticking = true;
      requestAnimationFrame(update);
    }
  }

  window.addEventListener('scroll', onScroll, { passive: true });
  window.addEventListener('resize', onScroll, { passive: true });
  update();
})();
</script>
<script>
(function () {
  const grid = document.querySelector('#bodymap-gallery .pink-grid');
  if (!grid) return;

  // Fallback: visa direkt om IO saknas
  if (!('IntersectionObserver' in window)) {
    grid.classList.add('in-view');
    return;
  }

  const io = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting && entry.intersectionRatio > 0.25) {
        grid.classList.add('in-view');
      } else {
        grid.classList.remove('in-view');
      }
    });
  }, {
    root: null,
    threshold: [0, 0.25, 0.5],
    rootMargin: '0px 0px -10% 0px'
  });

  io.observe(grid);
})();
</script>
<script>
(function () {
  // Alla fem sektioner
  const sections = [
    { id: '#moodboard-section-1', dir: 'left' },
    { id: '#moodboard-section-2', dir: 'right' },
    { id: '#moodboard-section-3', dir: 'left' },
    { id: '#moodboard-section-4', dir: 'right' },
    { id: '#moodboard-section-5', dir: 'left' }
  ];

  const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
  let ticking = false;

  function animate(img, direction) {
    const rect = img.getBoundingClientRect();
    const vh = window.innerHeight;
    const startY = vh * 0.85;
    const endY = vh * 0.35;

    let p = (startY - rect.top) / (startY - endY);
    p = Math.min(Math.max(p, 0), 1);
    const e = easeOutCubic(p);

    const tx = (direction === 'right' ? 160 : -160) * (1 - e);
    img.style.transform = `translateX(${tx}px)`;
    img.style.opacity = String(e);
  }

  function update() {
    ticking = false;
    sections.forEach(({ id, dir }) => {
      const img = document.querySelector(`${id} .mood img`);
      if (img) animate(img, dir);
    });
  }

  function onScroll() {
    if (!ticking) {
      ticking = true;
      requestAnimationFrame(update);
    }
  }

  window.addEventListener('scroll', onScroll, { passive: true });
  window.addEventListener('resize', onScroll, { passive: true });
  update();
})();
</script>
<script>
(function(){
  const root     = document.getElementById('result-gallery');
  if(!root) return;

  const slides   = Array.from(root.querySelectorAll('.rg-slide'));
  const prevBtn  = root.querySelector('.rg-prev');
  const nextBtn  = root.querySelector('.rg-next');
  const caption  = root.querySelector('#rg-caption');

  // Optional: dynamic captions per slide (edit if you want)
  const captions = [
    'Testing the heating element for consistent warmth across the abdomen and chest.',
    'Breathing-synchronised light prototype to support calm and presence.',
    'Exploring fabrics and weights to balance comfort and pressure.',
    'Embedding RGB LEDs and routing wiring for a soft, seamless look.',
    'Shaping and placement aligned with soma explorations and body maps.',
    'Final appearance and feel of the prototype in use.'
  ];

  let index = 0;
  const last = slides.length - 1;

  function show(i){
    index = (i + slides.length) % slides.length;
    slides.forEach((el, j) => {
      el.setAttribute('aria-hidden', String(j !== index));
    });
    if(caption) caption.textContent = captions[index] || caption.textContent;
  }

  function step(dir){ show(index + dir); }

  prevBtn.addEventListener('click', () => step(-1));
  nextBtn.addEventListener('click', () => step(1));

  // Keyboard arrows
  root.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft')  step(-1);
    if (e.key === 'ArrowRight') step(1);
  });
  root.tabIndex = 0; // make region focusable for keyboard nav

  // Touch swipe
  let startX = 0, dx = 0, touching = false;
  const viewport = root.querySelector('.rg-viewport');

  viewport.addEventListener('touchstart', e => {
    touching = true;
    startX = e.touches[0].clientX;
    dx = 0;
  }, {passive:true});

  viewport.addEventListener('touchmove', e => {
    if (!touching) return;
    dx = e.touches[0].clientX - startX;
  }, {passive:true});

  viewport.addEventListener('touchend', () => {
    if (!touching) return;
    touching = false;
    if (Math.abs(dx) > 40) step(dx < 0 ? 1 : -1);
  }, {passive:true});

  // Initial render
  show(0);
})();
</script>
<script>
  // Hämta alla pop-in-element i ordning och ge dem ett index för fördröjning
  const items = document.querySelectorAll('.pop-in');
  items.forEach((el, idx) => el.dataset.idx = idx);

  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (!entry.isIntersecting) return;

      const idx = Number(entry.target.dataset.idx) || 0;
      // Stagger: 120ms mellan varje i vänster->höger-ordning
      setTimeout(() => {
        entry.target.classList.add('visible');
      }, idx * 120);

      observer.unobserve(entry.target);
    });
  }, { threshold: 0.2 });

  items.forEach(el => observer.observe(el));
</script>






</html>